---
description: 
globs: 
alwaysApply: true
---
# Top-Down Design - Refactorisation des Fonctions Complexes

## Principe G√©n√©ral

Quand une fonction d√©passe **100 lignes** ou devient **difficile √† comprendre**, appliquez le **Top-Down Design** pour la d√©composer en sous-fonctions claires et sp√©cialis√©es.

## R√®gles d'Application

### ‚úÖ Quand Refactoriser

- **Longueur** : Fonction > 100 lignes
- **Complexit√©** : Logique m√©tier m√©lang√©e (validation + API + BDD)
- **Lisibilit√©** : Conditions imbriqu√©es difficiles √† suivre
- **Testabilit√©** : Impossible de tester unitairement
- **Maintenance** : Modification d'une partie affecte tout le reste

### üéØ M√©thodologie Top-Down

#### 1. **Identifier les √âtapes Principales**
```typescript
// ‚ùå AVANT : Fonction monolithique
export async function complexFunction() {
  // 150 lignes de code m√©lang√©...
}

// ‚úÖ APR√àS : Vue d'ensemble claire
export async function complexFunction() {
  // 1Ô∏è‚É£ Validation des param√®tres
  const validatedData = validateInput(params)
  
  // 2Ô∏è‚É£ Logique m√©tier principale
  const processedData = await processBusinessLogic(validatedData)
  
  // 3Ô∏è‚É£ Persistance des donn√©es
  const result = await saveData(processedData)
  
  // 4Ô∏è‚É£ Retour format√©
  return formatResponse(result)
}
```

#### 2. **Cr√©er des Fonctions Sp√©cialis√©es**
Chaque sous-fonction a **une seule responsabilit√©** :

```typescript
// Validation pure
function validateInput(params: InputParams): ValidatedData {
  // Logique de validation isol√©e
}

// Logique m√©tier pure
async function processBusinessLogic(data: ValidatedData): Promise<ProcessedData> {
  // Transformation des donn√©es m√©tier
}

// Acc√®s donn√©es pur
async function saveData(data: ProcessedData): Promise<SaveResult> {
  // Interaction avec la base de donn√©es
}

// Formatage pur
function formatResponse(result: SaveResult): ApiResponse {
  // Transformation pour l'API
}
```

#### 3. **Types Explicites pour Chaque √âtape**
```typescript
// Types clairs pour le flux de donn√©es
type InputParams = { /* ... */ }
type ValidatedData = { /* ... */ }
type ProcessedData = { /* ... */ }
type SaveResult = { /* ... */ }
type ApiResponse = { /* ... */ }
```

## Exemple Concret : Checkout Stripe

### R√©f√©rence : [external-checkout/actions.ts](mdc:src/components/features/checkout-stripe/external-checkout/actions.ts)

#### ‚úÖ Top-Down Appliqu√©
```typescript
export async function createCheckoutSession(priceId: string, seats: number, guest: boolean) {
  // Vue d'ensemble du processus
  const user = await getAuthUser()
  const plan = getPlanByPriceId(priceId)
  
  // 1Ô∏è‚É£ Validation du mode
  const mode = checkCheckoutMode(guest, user)
  
  // 2Ô∏è‚É£ Gestion customer
  const customerInfo = await initUserCustomer(mode, user)
  
  // 3Ô∏è‚É£ Initialisation subscription
  const subscriptionId = await initSubscription(customerInfo, plan.planCode, seats)
  
  // 4Ô∏è‚É£ Cr√©ation metadata
  const metadata = createMetadata(mode, subscriptionData, customerInfo)
  
  // 5Ô∏è‚É£ Cr√©ation session Stripe
  const session = await createStripeSession(priceId, subscriptionData, customerInfo, metadata)
  
  return { success: true, url: session.url, sessionId: session.id }
}
```

#### üîß Fonctions Sp√©cialis√©es
```typescript
// Chaque fonction a un r√¥le pr√©cis
function checkCheckoutMode(guest: boolean, user: User | undefined): CheckoutMode
async function initUserCustomer(mode: CheckoutMode, user: User | undefined): Promise<CustomerInfo>
async function initSubscription(customerInfo: CustomerInfo, planCode: SubscriptionPlan, seats: number): Promise<string>
function createMetadata(mode: CheckoutMode, subscriptionData: SubscriptionData, customerInfo: CustomerInfo): Record<string, string>
async function createStripeSession(priceId: string, subscriptionData: SubscriptionData, customerInfo: CustomerInfo, metadata: Record<string, string>): Promise<StripeSession>
```

## Avantages du Top-Down

### ‚úÖ **Lisibilit√© Maximale**
- Fonction principale = table des mati√®res
- Chaque √©tape clairement identifi√©e
- Flux logique √©vident

### ‚úÖ **Maintenabilit√© Optimale**
- Modification isol√©e dans une seule fonction
- Impact limit√© sur le reste du code
- Debugging plus facile

### ‚úÖ **Testabilit√© Parfaite**
- Tests unitaires pour chaque fonction
- Mocks isol√©s et pr√©cis
- Couverture de code granulaire

### ‚úÖ **R√©utilisabilit√©**
- Fonctions r√©utilisables dans d'autres contextes
- Logic m√©tier extraite et portable
- DRY (Don't Repeat Yourself) respect√©

## Checklist de Refactorisation

### üîç **Avant de Commencer**
- [ ] Fonction > 100 lignes ?
- [ ] Logique m√©lang√©e (validation + m√©tier + persistance) ?
- [ ] Conditions imbriqu√©es complexes ?
- [ ] Tests difficiles √† √©crire ?

### üõ†Ô∏è **√âtapes de Refactorisation**
- [ ] Identifier les 4-6 √©tapes principales
- [ ] Cr√©er les types pour chaque √©tape
- [ ] Extraire chaque √©tape en fonction sp√©cialis√©e
- [ ] Fonction principale = orchestration simple
- [ ] Ajouter logs pour chaque √©tape
- [ ] Tests unitaires pour chaque fonction

### ‚úÖ **Validation du R√©sultat**
- [ ] Fonction principale < 50 lignes
- [ ] Chaque sous-fonction < 30 lignes
- [ ] Une responsabilit√© par fonction
- [ ] Types explicites partout
- [ ] Testable unitairement
- [ ] Logs clairs et informatifs

## Patterns √† √âviter

### ‚ùå **Anti-Patterns**
```typescript
// Fonction trop g√©n√©rique
function processEverything(data: any): any

// Logique m√©lang√©e
function validateAndSaveAndNotify() {
  // validation + BDD + email dans la m√™me fonction
}

// Param√®tres multiples non typ√©s
function complexProcess(a: string, b: number, c: boolean, d: any[], e: object)
```

### ‚úÖ **Bonnes Pratiques**
```typescript
// Fonction sp√©cialis√©e avec types
function validateUserInput(input: UserInput): ValidatedUser

// Responsabilit√© unique
function saveUser(user: ValidatedUser): Promise<SavedUser>
function sendWelcomeEmail(user: SavedUser): Promise<void>

// Param√®tres structur√©s
function processUser(params: ProcessUserParams): Promise<ProcessUserResult>
```

## Application dans le Projet

Appliquez cette m√©thodologie sur :
- Server Actions complexes
- Services m√©tier longs
- Fonctions de validation √©tendues
- Logique de transformation de donn√©es
- Orchestration d'APIs multiples

**Objectif** : Code lisible, maintenable et testable √† tous les niveaux.
