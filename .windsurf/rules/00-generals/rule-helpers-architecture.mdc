---
description: 
globs: 
alwaysApply: false
---
# Architecture des Helpers - SÃ©paration Client/Serveur

## Principe GÃ©nÃ©ral

L'architecture des helpers suit une **sÃ©paration stricte** entre le code client et serveur selon l'emplacement des fichiers.

---

## RÃ©partition par Dossiers

### ğŸ“‚ **`src/lib/helper/` - EXCLUSIVEMENT CLIENT**

- **Contrainte** : Code exÃ©cutable **uniquement cÃ´tÃ© navigateur**
- **Usage** : Fonctions utilitaires pour les composants React et logique UI
- **Interdiction** : Aucun accÃ¨s aux ressources serveur (env, DB, API externes)

### ğŸ“‚ **`src/services/` - HELPERS SERVEUR AUTORISÃ‰S**

- **Contrainte** : Code exÃ©cutable **cÃ´tÃ© serveur uniquement**  
- **Usage** : Logique mÃ©tier, validation, transformation de donnÃ©es serveur
- **Autorisation** : AccÃ¨s complet aux ressources serveur

### ğŸ“‚ **`src/db/` - HELPERS BASE DE DONNÃ‰ES**

- **Contrainte** : Code d'accÃ¨s aux donnÃ©es
- **Usage** : Helpers pour requÃªtes, transformations de modÃ¨les
- **Autorisation** : AccÃ¨s ORM, repositories, migrations

---

## RÃ¨gles par Emplacement

### âœ… **`/lib/helper/` - Code Client Pur**

```typescript
// âœ… AUTORISÃ‰ dans /lib/helper/
export function formatPrice(amount: number, currency = 'EUR'): string {
  return new Intl.NumberFormat('fr-FR', {
    style: 'currency',
    currency
  }).format(amount)
}

export function validateEmail(email: string): boolean {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  return regex.test(email)
}

export function getReferenceIdByBillingMode(
  billingMode: BillingModes,
  userId: string,
  organizationId?: string
): string {
  return billingMode === BillingModes.ORGANIZATION 
    ? organizationId || userId 
    : userId
}
```

### âœ… **`/services/` - Helpers Serveur MÃ©tier**

```typescript
// âœ… AUTORISÃ‰ dans /services/helpers/
import { env } from '@/env'
import { getReferenceIdByBillingMode } from '@/lib/helper/subscription-helper'

export function getCurrentBillingMode(): BillingModes {
  return env.NEXT_PUBLIC_BILLING_MODE
}

export function getCurrentReferenceId(
  userId: string, 
  organizationId?: string
): string {
  return getReferenceIdByBillingMode(
    getCurrentBillingMode(),
    userId,
    organizationId
  )
}

export async function processSubscriptionWebhook(
  event: StripeEvent
): Promise<void> {
  // Logique complexe serveur avec accÃ¨s DB
}
```

### âœ… **`/db/` - Helpers Base de DonnÃ©es**

```typescript
// âœ… AUTORISÃ‰ dans /db/helpers/
import { eq } from 'drizzle-orm'
import db from '@/db/models/db'
import { users, subscriptions } from '@/db/models/schema'

export async function findUserWithActiveSubscription(userId: string) {
  return await db
    .select()
    .from(users)
    .leftJoin(subscriptions, eq(users.id, subscriptions.referenceId))
    .where(eq(users.id, userId))
}

export function transformUserModelToDTO(userModel: UserModel): UserDTO {
  // Transformation modÃ¨le -> DTO
}
```

---

## Architecture RecommandÃ©e

### **Structure des Dossiers**

```
src/
â”œâ”€â”€ lib/helper/              # ğŸ”µ CLIENT UNIQUEMENT
â”‚   â”œâ”€â”€ date-helper.ts       # Formatage dates cÃ´tÃ© client
â”‚   â”œâ”€â”€ format-helper.ts     # Formatage donnÃ©es UI
â”‚   â”œâ”€â”€ validation-helper.ts # Validation formulaires
â”‚   â””â”€â”€ subscription-helper.ts # Logique rÃ©fÃ©rence client
â”‚
â”œâ”€â”€ services/               # ğŸŸ  SERVEUR + LOGIQUE MÃ‰TIER
â”‚   â”œâ”€â”€ helpers/            # Helpers logique mÃ©tier
â”‚   â”‚   â”œâ”€â”€ billing-helper.ts
â”‚   â”‚   â””â”€â”€ email-helper.ts
â”‚   â”œâ”€â”€ user-service.ts
â”‚   â””â”€â”€ subscription-service.ts
â”‚
â””â”€â”€ db/                     # ğŸŸ¢ ACCÃˆS DONNÃ‰ES
    â”œâ”€â”€ helpers/            # Helpers base de donnÃ©es
    â”‚   â”œâ”€â”€ query-helper.ts
    â”‚   â””â”€â”€ transform-helper.ts
    â”œâ”€â”€ models/
    â””â”€â”€ repositories/
```

---

## Flux de DonnÃ©es RecommandÃ©

### **Client â†’ Serveur â†’ Base de DonnÃ©es**

```typescript
// 1ï¸âƒ£ COMPOSANT CLIENT utilise helper client
import { getReferenceIdByBillingMode } from '@/lib/helper/subscription-helper'
import { getCurrentBillingMode } from '@/services/helpers/billing-helper'

function SubscriptionComponent() {
  const referenceId = getReferenceIdByBillingMode(
    getCurrentBillingMode(), // RÃ©cupÃ©rÃ© cÃ´tÃ© serveur
    user.id,
    organization?.id
  )
}

// 2ï¸âƒ£ SERVICE utilise helper serveur + client
import { getReferenceIdByBillingMode } from '@/lib/helper/subscription-helper'

export async function createSubscriptionService(
  userId: string,
  organizationId?: string
) {
  const referenceId = getReferenceIdByBillingMode(
    env.NEXT_PUBLIC_BILLING_MODE,
    userId,
    organizationId
  )
  
  // Logique mÃ©tier serveur...
}

// 3ï¸âƒ£ REPOSITORY utilise helper DB
import { transformUserModelToDTO } from '@/db/helpers/transform-helper'

export async function getUserByIdDao(id: string): Promise<UserDTO> {
  const userModel = await db.query.users.findFirst({
    where: eq(users.id, id)
  })
  
  return transformUserModelToDTO(userModel)
}
```

---

## Contraintes Strictes

### âŒ **INTERDIT dans `/lib/helper/`**

```typescript
// âŒ Variables d'environnement
import { env } from '@/env'
export const BILLING_MODE = env.NEXT_PUBLIC_BILLING_MODE

// âŒ AccÃ¨s base de donnÃ©es
import db from '@/db/models/db'
export async function getUser(id: string) {
  return await db.query.users.findFirst()
}

// âŒ Appels API externes
export async function fetchStripeCustomer(id: string) {
  return await stripe.customers.retrieve(id)
}
```

### âœ… **AUTORISÃ‰ partout ailleurs**

- **`/services/helpers/`** : Toute logique serveur, env, API
- **`/db/helpers/`** : AccÃ¨s DB, ORM, transformations modÃ¨les
- **`/app/`** : Server Actions avec accÃ¨s complet serveur

---

## Migration des Helpers Existants

### **Ã‰tapes de Migration**

1. **Identifier l'usage** : Client ou serveur ?
2. **DÃ©placer si nÃ©cessaire** :
   - Client â†’ garder dans `/lib/helper/`
   - Serveur â†’ dÃ©placer vers `/services/helpers/` ou `/db/helpers/`
3. **Refactoriser les dÃ©pendances** : Passer paramÃ¨tres au lieu d'importer
4. **Tester** : Valider cÃ´tÃ© client ET serveur

### **Exemple Concret : subscription-helper.ts**

**Avant (Violation)** :
```typescript
// âŒ /lib/helper/subscription-helper.ts
import { env } from '@/env'

export const BILLING_MODE = env.NEXT_PUBLIC_BILLING_MODE // SERVEUR dans CLIENT !

export function getReferenceIdByBillingMode(
  userId?: string,
  organizationId?: string
): string | undefined {
  // Logique client valide
}
```

**AprÃ¨s (Conforme)** :
```typescript
// âœ… /lib/helper/subscription-helper.ts - CLIENT PUR
export function getReferenceIdByBillingMode(
  billingMode: BillingModes,
  userId: string,
  organizationId?: string
): string {
  return billingMode === BillingModes.ORGANIZATION 
    ? organizationId || userId 
    : userId
}

// âœ… /services/helpers/billing-helper.ts - SERVEUR
import { env } from '@/env'
import { getReferenceIdByBillingMode } from '@/lib/helper/subscription-helper'

export function getCurrentBillingMode(): BillingModes {
  return env.NEXT_PUBLIC_BILLING_MODE
}

export function getCurrentReferenceId(
  userId: string,
  organizationId?: string
): string {
  return getReferenceIdByBillingMode(
    getCurrentBillingMode(),
    userId,
    organizationId
  )
}
```

---

## Tests et Validation

### **Tests par Emplacement**

- **`/lib/helper/`** : Tests unitaires exÃ©cutables cÃ´tÃ© client
- **`/services/helpers/`** : Tests avec mocks des ressources serveur
- **`/db/helpers/`** : Tests d'intÃ©gration avec base de donnÃ©es

### **CritÃ¨res de Validation**

- [ ] `/lib/helper/` â†’ Aucune dÃ©pendance serveur
- [ ] `/services/helpers/` â†’ Logique mÃ©tier validÃ©e
- [ ] `/db/helpers/` â†’ AccÃ¨s donnÃ©es optimisÃ©
- [ ] Tests complets pour chaque emplacement
- [ ] Documentation claire de l'usage

---

## RÃ©sumÃ©

### ğŸ¯ **RÃ¨gle d'Or**

- **`/lib/helper/`** = Client pur (navigateur uniquement)
- **`/services/helpers/`** = Serveur + logique mÃ©tier
- **`/db/helpers/`** = AccÃ¨s base de donnÃ©es

### ğŸ”„ **Flux Optimal**

**Client** â†’ utilise helpers client â†’ appelle services â†’ utilisent helpers serveur â†’ appellent DB â†’ utilisent helpers DB

Cette architecture garantit une **sÃ©paration claire**, une **maintenabilitÃ© optimale** et des **tests ciblÃ©s** selon le contexte d'exÃ©cution.
