---
description: 
globs: 
alwaysApply: false
---
# Gestion des Logs avec Winston Logger

Key Principles
- Utilisation de winston via `import { logger } from '@/lib/logger'`
- Avoir un juste √©quuilibre de logging (pas trop de log)
- Les service passent deja par des interceptor de logging


## Configuration du Logger

Le projet utilise **Winston** pour la gestion des logs c√¥t√© serveur uniquement. Le logger est configur√© dans [logger.ts](mdc:src/lib/logger.ts).

```ts
import { logger } from '@/lib/logger'
```

## ‚ö†Ô∏è Restriction Importante

**Le logger ne fonctionne QUE c√¥t√© serveur** :
- ‚úÖ Server Components
- ‚úÖ Server Actions  
- ‚úÖ API Routes
- ‚úÖ Services m√©tier
- ‚úÖ DAL (Data Access Layer)
- ‚úÖ Webhooks
- ‚ùå Client Components (utiliser `console.log` √† la place)

## Niveaux de Log Disponibles

```ts
// Niveau ERROR - Erreurs critiques
logger.error('‚ùå Erreur critique:', error)

// Niveau INFO - Informations importantes
logger.info('‚úÖ Op√©ration r√©ussie:', data)

// Niveau DEBUG - Informations de d√©bogage (d√©veloppement)
logger.debug('üîß Donn√©es de d√©bogage:', metadata)

// Niveau LOG - Informations g√©n√©rales
logger.log('üìù Information g√©n√©rale:', message)
```

## Utilisation dans les Services

### Logging Automatique avec Intercepteurs

Les services disposent d'intercepteurs automatiques qui loggent les appels de m√©thodes :

[organization-service-logger-interceptor.ts](mdc:src/services/facades/interceptors/organization-service-logger-interceptor.ts)

```ts
// Les intercepteurs loggent automatiquement :
// - L'appel de chaque m√©thode de service
// - Les arguments pass√©s (en mode debug)
// - Le r√©sultat retourn√© (en mode debug)  
// - Les erreurs d'autorisation et autres
```

### Logging Manuel dans les Services

```ts
import { logger } from '@/lib/logger'

export const createUserService = async (userData: CreateUser) => {
  logger.info('[USER-SERVICE] Cr√©ation utilisateur d√©marr√©e')
  
  try {
    const user = await createUserDao(userData)
    logger.info('‚úÖ Utilisateur cr√©√© avec succ√®s:', user.email)
    return user
  } catch (error) {
    logger.error('‚ùå Erreur cr√©ation utilisateur:', error)
    throw error
  }
}
```

## Utilisation dans les Webhooks

Exemple d'usage dans les webhooks Stripe [stripe-events.ts](mdc:src/lib/stripe/stripe-events.ts) :

```ts
export async function onStripeEvent(event: Stripe.Event) {
  logger.info('Better Auth Stripe event:', event.type, event.id)
  
  try {
    // Traitement...
    logger.debug('üîß Donn√©es m√©tadata:', metadata)
    logger.log('‚úÖ Traitement termin√© avec succ√®s')
  } catch (error) {
    logger.error('‚ùå Erreur dans onEvent Stripe:', error)
  }
}
```

## Bonnes Pratiques

### 1. Utilisation des Emojis pour Identifier les Types

```ts
// ‚úÖ Succ√®s / Op√©ration r√©ussie
logger.info('‚úÖ Utilisateur authentifi√©:', user.email)

// ‚ùå Erreurs
logger.error('‚ùå √âchec de l\'authentification:', error)

// üîß Debug / D√©veloppement
logger.debug('üîß Variables d\'environnement:', process.env.NODE_ENV)

// üìù Informations g√©n√©rales
logger.log('üìù D√©marrage de l\'application')

// ‚ö†Ô∏è Avertissements
logger.warn('‚ö†Ô∏è Configuration manquante:', config)
```

### 2. Logging Structur√© avec M√©tadonn√©es

```ts
// Bon - avec m√©tadonn√©es structur√©es
logger.info('Utilisateur connect√©', {
  userId: user.id,
  email: user.email,
  timestamp: new Date().toISOString()
})

// √âviter - texte non structur√©
logger.info(`Utilisateur ${user.email} connect√© √† ${new Date()}`)
```

### 3. Gestion des Erreurs

```ts
try {
  // Code m√©tier
} catch (error) {
  if (error instanceof AuthorizationError) {
    logger.error('[AUTH] Erreur d\'autorisation:', error.message)
  } else if (error instanceof ValidationError) {
    logger.error('[VALIDATION] Erreur de validation:', error.message)
  } else {
    logger.error('[SYSTEM] Erreur syst√®me:', error)
  }
  throw error
}
```

### 4. Logging dans les Server Actions

```ts
'use server'

export async function updateUserAction(formData: FormData) {
  logger.info('[ACTION] Mise √† jour utilisateur d√©marr√©e')
  
  try {
    const result = await updateUserService(data)
    logger.info('‚úÖ Action termin√©e avec succ√®s')
    return result
  } catch (error) {
    logger.error('‚ùå Erreur dans l\'action:', error)
    throw error
  }
}
```

## Configuration des Niveaux

Le niveau de log est contr√¥l√© par la variable d'environnement `LOG_LEVEL` :

```env
# D√©veloppement - voir tous les logs
LOG_LEVEL=debug

# Production - logs essentiels uniquement  
LOG_LEVEL=info
```

## Format des Logs

Les logs incluent automatiquement :
- **Timestamp** : Date et heure formatted
- **Level** : Niveau du log (coloris√© en console)
- **Message** : Message principal
- **Metadata** : Donn√©es structur√©es (JSON)

Exemple de sortie :
```
2024-01-15 14:30:25 [info]: ‚úÖ Utilisateur cr√©√© avec succ√®s | {"email":"user@example.com","id":"123"}
```

## Attention : Client vs Server

```ts
// ‚ùå NE FONCTIONNE PAS c√¥t√© client
'use client'
import { logger } from '@/lib/logger' // Erreur !

// ‚úÖ Utilisez console.log c√¥t√© client
'use client'
console.log('Debug c√¥t√© client:', data)

// ‚úÖ Fonctionne c√¥t√© serveur
'use server'  
import { logger } from '@/lib/logger'
logger.info('Log c√¥t√© serveur:', data)
```

Cette approche garantit un logging robuste et structur√© pour tout le code c√¥t√© serveur de l'application.


