---
description:
globs:
alwaysApply: false
---
# Système d'Upload de Fichiers et Images

Guide complet pour l'upload de fichiers et d'images dans l'architecture Next.js 15 / React 19.

## Architecture d'Upload

### Flux de données pour l'upload
**Client Components** → **Server Actions** → **Service Facades** → **Services** → **Repository**

### Technologies utilisées
- **Supabase Storage** pour le stockage des fichiers
- **React Dropzone** pour l'interface de glisser-déposer
- **Framer Motion** pour les animations
- **FileUpload Component** personnalisé avec ShadCN UI

## Composant FileUpload

**Référence : [file-upload.tsx](mdc:src/components/ui/file-upload.tsx)**

### Utilisation basique

```tsx
import {FileUpload} from '@/components/ui/file-upload'

// Upload d'image unique
<FileUpload
  onChange={handleFileUpload}
  onlyimage={true}
  multi={false}
  isUploading={isUploading}
/>

// Upload de fichiers multiples
<FileUpload
  onChange={handleFileUpload}
  multi={true}
  isUploading={isUploading}
/>
```

### Props du composant FileUpload

- `onChange: (files: File[]) => void` - Callback appelé lors de la sélection de fichiers
- `multi?: boolean` - Permet la sélection multiple (défaut: false)
- `onlyimage?: boolean` - Restreint aux images uniquement (défaut: false)
- `isUploading?: boolean` - État de chargement pour désactiver l'interface

### Types d'images supportés
**Référence : [file-types.ts](mdc:src/services/types/domain/file-types.ts)**

```tsx
// Types MIME autorisés pour les images
export const ALLOWED_IMAGE_MIME_TYPES = [
  'image/webp',
  'image/jpeg', 
  'image/jpg',
  'image/png'
] as const
```

## Pattern d'Implémentation Frontend

**Référence : [edit-organization-form.tsx](mdc:src/components/features/organization/edit-organization-form.tsx)**

### Template standard pour un formulaire avec upload

```tsx
'use client'

import {useState} from 'react'
import {useForm} from 'react-hook-form'
import {toast} from 'sonner'
import {FileUpload} from '@/components/ui/file-upload'

export function FormWithUpload({entity}: {entity: EntityType}) {
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [isUploading, setIsUploading] = useState(false)
  const [entityImage, setEntityImage] = useState(entity.image ?? '')

  const form = useForm({
    defaultValues: {
      id: entity.id,
      image: entity.image ?? '',
      // autres champs...
    },
  })

  async function handleFileUpload(files: File[]) {
    if (files.length === 0) return

    const file = files[0]
    setIsUploading(true)

    try {
      const formData = new FormData()
      formData.append('file', file)
      formData.append('entityId', entity.id) // ID de l'entité associée

      const result = await uploadEntityImageAction(undefined, formData)

      if (result.success && result.imageUrl) {
        // Mettre à jour le formulaire avec l'URL de l'image
        form.setValue('image', result.imageUrl)
        setEntityImage(result.imageUrl)

        toast('Succès', {
          description: result.message,
        })
      } else {
        toast('Erreur', {
          description: result.message || "Erreur lors de l'upload",
        })
      }
    } catch (error) {
      console.error("Erreur lors de l'upload:", error)
      toast('Erreur', {
        description: "Impossible d'uploader l'image. Veuillez réessayer.",
      })
    } finally {
      setIsUploading(false)
    }
  }

  return (
    <Form {...form}>
      <div className="space-y-2">
        <FileUpload
          onChange={handleFileUpload}
          onlyimage={true}
          multi={false}
          isUploading={isUploading}
        />
        {isUploading && (
          <p className="text-muted-foreground text-sm">Upload en cours...</p>
        )}
      </div>
      {/* Autres champs du formulaire */}
    </Form>
  )
}
```

## Server Actions d'Upload

**Référence : [action.ts](mdc:src/components/features/organization/action.ts)**

### Template standard d'une Server Action d'upload

```tsx
'use server'

import {getAuthUser} from '@/services/authentication/auth-utils'
import {uploadImageForEntityService} from '@/services/facades/file-service-facade'
import {
  EntityTypeConst,
  FileCategoryConst,
} from '@/services/types/domain/file-types'

export type UploadImageState = {
  success: boolean
  message?: string
  imageUrl?: string
}

export async function uploadEntityImageAction(
  prevState?: UploadImageState,
  formData?: FormData
): Promise<UploadImageState> {
  // 1. VÉRIFICATION AUTHENTIFICATION
  const user = await getAuthUser()
  if (!user) {
    return {success: false, message: 'Utilisateur non trouvé'}
  }
  
  // 2. VALIDATION FORMDATA
  if (!formData) {
    return {success: false, message: 'Données invalides'}
  }

  const file = formData.get('file') as File
  const entityId = formData.get('entityId') as string

  // 3. VALIDATION FICHIER
  if (!file || file.size === 0) {
    return {success: false, message: 'Aucun fichier fourni'}
  }

  if (!entityId) {
    return {success: false, message: "ID d'entité manquant"}
  }

  try {
    // 4. UPLOAD VIA SERVICE FACADE
    const result = await uploadImageForEntityService({
      file,
      entityType: EntityTypeConst.ORGANIZATION, // ou USER, PRODUCT, etc.
      entityId,
      category: FileCategoryConst.LOGO, // ou PROFILE, IMAGE, etc.
    })

    return {
      success: true,
      message: 'Image uploadée avec succès',
      imageUrl: result.url,
    }
  } catch (error) {
    console.error("Erreur lors de l'upload:", error)
    return {
      success: false,
      message: "Impossible d'uploader l'image. Veuillez réessayer.",
    }
  }
}
```

## Services d'Upload

**Référence : [file-service.ts](mdc:src/services/file-service.ts)**

### Service spécialisé pour les images

```tsx
/**
 * Upload une image avec génération automatique du chemin pour une entité
 *
 * Spécialisé pour les images uniquement avec validation stricte des types MIME
 * Types autorisés : WebP, JPEG, JPG, PNG
 *
 * Exemples de chemins générés :
 * - User profile: "users/123/profile-1703123456789.webp"
 * - Organization logo: "organizations/456/logo-1703123456789.png"
 */
export const uploadImageForEntityService = async (
  params: UploadFileForEntity
): Promise<FileResponse>
```

### Service générique pour tous types de fichiers

```tsx
/**
 * Upload un fichier avec génération automatique du chemin pour une entité
 *
 * Génère automatiquement un chemin de la forme : 
 * `{entityType}s/{entityId}/{category}-{timestamp}.{extension}`
 */
export const uploadFileForEntityService = async (
  params: UploadFileForEntity
): Promise<FileResponse>
```

## Types et Constantes

### Types principaux

```tsx
// Types d'entités supportées
export enum EntityTypeConst {
  USER = 'user',
  ORGANIZATION = 'organization',
  PRODUCT = 'product',
}

// Catégories de fichiers
export enum FileCategoryConst {
  PROFILE = 'profile',
  LOGO = 'logo',
  IMAGE = 'image',
  DOCUMENT = 'document',
}

// Paramètres d'upload
export type UploadFileForEntity = {
  file: File
  entityType: EntityType
  entityId: string
  category?: FileCategory
}

// Réponse d'upload
export type FileResponse = {
  path: string
  url: string
  size: number
  type: string
  name: string
}
```

## Configuration Supabase Storage

### Variables d'environnement requises

```env
SUPABASE_URL=your_supabase_url
SUPABASE_ANON_KEY=your_anon_key
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
```

### Génération automatique des chemins

```tsx
// Exemple de chemin généré automatiquement
const generateFilePath = (
  entityType: EntityType,
  entityId: string,
  file: File,
  category: FileCategory = 'image'
): string => {
  const timestamp = Date.now()
  const fileExtension = file.name.split('.').pop()
  return `${entityType}s/${entityId}/${category}-${timestamp}.${fileExtension}`
}

// Résultat : "organizations/123/logo-1703123456789.png"
```

## Exemples d'Utilisation

### Upload d'avatar utilisateur

**Référence : [edit-user-profile.tsx](mdc:src/components/features/user/edit-user-profile.tsx)**

```tsx
// Générera : "users/user-id/profile-timestamp.webp"
const result = await uploadImageForEntityService({
  file,
  entityType: EntityTypeConst.USER,
  entityId: user.id,
  category: FileCategoryConst.PROFILE,
})
```

### Upload de logo d'organisation

**Référence : [edit-organization-form.tsx](mdc:src/components/features/organization/edit-organization-form.tsx)**

```tsx
// Générera : "organizations/org-id/logo-timestamp.png"
const result = await uploadImageForEntityService({
  file,
  entityType: EntityTypeConst.ORGANIZATION,
  entityId: organization.id,
  category: FileCategoryConst.LOGO,
})
```

## Gestion des Erreurs

### Validation côté client

```tsx
// Le composant FileUpload valide automatiquement :
// - Types MIME autorisés
// - Taille maximum configurée
// - Formats d'images supportés

const isValidFile = (file: File): boolean => {
  if (onlyimage) {
    return ALLOWED_IMAGE_MIME_TYPES.includes(file.type as any)
  }
  return true
}
```

### Validation côté serveur

```tsx
// Validation dans les services
if (file.size > config.maxFileSize) {
  throw FileErrors.FILE_TOO_LARGE(file.size, config.maxFileSize)
}

if (!ALLOWED_IMAGE_MIME_TYPES.includes(file.type)) {
  throw new Error(`Type d'image non supporté: ${file.type}`)
}
```

## États de Chargement

### Interface utilisateur réactive

```tsx
// État pendant l'upload
const [isUploading, setIsUploading] = useState(false)

// Feedback visuel
{isUploading && (
  <p className="text-muted-foreground text-sm">Upload en cours...</p>
)}

// Désactivation des interactions
<FileUpload isUploading={isUploading} />
```

## Bonnes Pratiques

### 1. Sécurité
- ✅ Toujours vérifier l'authentification dans les Server Actions
- ✅ Valider les types de fichiers côté client ET serveur
- ✅ Limiter la taille des fichiers
- ✅ Utiliser des chemins prédictibles et sécurisés

### 2. UX/UI
- ✅ Feedback visuel pendant l'upload (états de chargement)
- ✅ Messages d'erreur explicites en français
- ✅ Drag & drop intuitif avec animations
- ✅ Prévisualisation des images après upload

### 3. Architecture
- ✅ Respecter le flux des couches (Client → Server Action → Facade → Service)
- ✅ Utiliser les types TypeScript stricts
- ✅ Centraliser la logique d'upload dans les services
- ✅ Génération automatique des chemins de fichiers

### 4. Performance
- ✅ Upload en arrière-plan sans bloquer l'interface
- ✅ Validation immédiate côté client
- ✅ Optimisation des images (WebP préféré)
- ✅ Gestion du cache Supabase

## Checklist d'Implémentation

- [ ] **FileUpload Component** configuré avec les bonnes props
- [ ] **Server Action** avec validation auth + fichier
- [ ] **Service d'upload** via les façades
- [ ] **Types appropriés** (EntityType, FileCategory)
- [ ] **Gestion d'erreurs** côté client et serveur  
- [ ] **États de chargement** avec feedback visuel
- [ ] **Validation MIME types** pour les images
- [ ] **Toast notifications** pour le succès/erreur
- [ ] **Mise à jour du formulaire** avec l'URL résultante

Cette architecture garantit un système d'upload robuste, sécurisé et performant avec une excellente expérience utilisateur.
